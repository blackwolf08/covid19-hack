{"ast":null,"code":"import{always,block,call,clockRunning,cond,set,startClock,stopClock}from\"../base\";import{default as Clock}from\"../core/AnimatedClock\";import{evaluateOnce}from\"../derived/evaluateOnce\";function createOldAnimationObject(node,AnimationClass,value,config){var newClock=new Clock();var currentState=AnimationClass.getDefaultState();var alwaysNode;var isStarted=false;var isDone=false;var wasStopped=false;var animationCallback;var animation={start:function start(currentAnimationCallback){animationCallback=currentAnimationCallback;if(isStarted){animationCallback&&animationCallback({finished:false});return;}if(isDone){console.warn('Animation has been finished before');return;}if(!value.isNativelyInitialized()){return;}isStarted=true;evaluateOnce(set(currentState.position,value),currentState.position,function(){alwaysNode=always(set(value,block([cond(clockRunning(newClock),0,startClock(newClock)),node(newClock,currentState,config),cond(currentState.finished,[call([],function(){isStarted=false;if(!wasStopped){isDone=true;}value.__detachAnimation(animation);isDone=true;if(!wasStopped){wasStopped=false;}}),stopClock(newClock)]),currentState.position])));value.__attachAnimation(animation);alwaysNode.__addChild(value);});},__detach:function __detach(){animationCallback&&animationCallback({finished:isDone});animationCallback=null;alwaysNode.__removeChild(value);},stop:function stop(){if(isDone){console.warn('Calling stop has no effect as the animation has already completed');return;}if(!isStarted){console.warn(\"Calling stop has no effect as the animation hasn't been started\");return;}wasStopped=true;evaluateOnce(set(currentState.finished,1),currentState.finished);},__stopImmediately_testOnly:function __stopImmediately_testOnly(result){animation.stop();isDone=result;value.__detachAnimation(animation);}};return animation;}export default function backwardsCompatibleAnimWrapper(node,AnimationClass){return function(clock,state,config){if(config!==undefined){return node(clock,state,config);}return createOldAnimationObject(node,AnimationClass,clock,state);};}","map":{"version":3,"sources":["/media/blackwolf08/Data/New Projects/Covid-19/COVID19/node_modules/react-native-reanimated/src/animations/backwardCompatibleAnimWrapper.js"],"names":["always","block","call","clockRunning","cond","set","startClock","stopClock","default","Clock","evaluateOnce","createOldAnimationObject","node","AnimationClass","value","config","newClock","currentState","getDefaultState","alwaysNode","isStarted","isDone","wasStopped","animationCallback","animation","start","currentAnimationCallback","finished","console","warn","isNativelyInitialized","position","__detachAnimation","__attachAnimation","__addChild","__detach","__removeChild","stop","__stopImmediately_testOnly","result","backwardsCompatibleAnimWrapper","clock","state","undefined"],"mappings":"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","sourcesContent":["import {\n  always,\n  block,\n  call,\n  clockRunning,\n  cond,\n  set,\n  startClock,\n  stopClock,\n} from '../base';\nimport { default as Clock } from '../core/AnimatedClock';\nimport { evaluateOnce } from '../derived/evaluateOnce';\n\nfunction createOldAnimationObject(node, AnimationClass, value, config) {\n  const newClock = new Clock();\n  const currentState = AnimationClass.getDefaultState();\n  let alwaysNode;\n  let isStarted = false;\n  let isDone = false;\n  let wasStopped = false;\n  let animationCallback;\n  const animation = {\n    start: currentAnimationCallback => {\n      animationCallback = currentAnimationCallback;\n      if (isStarted) {\n        animationCallback && animationCallback({ finished: false });\n        return;\n      }\n      if (isDone) {\n        console.warn('Animation has been finished before');\n        // inconsistent with React Native\n        return;\n      }\n\n      if (!value.isNativelyInitialized()) {\n        return;\n      }\n\n      isStarted = true;\n      evaluateOnce(\n        set(currentState.position, value),\n        currentState.position,\n        () => {\n          alwaysNode = always(\n            set(\n              value,\n              block([\n                cond(clockRunning(newClock), 0, startClock(newClock)),\n                node(newClock, currentState, config),\n                cond(currentState.finished, [\n                  call([], () => {\n                    isStarted = false;\n                    if (!wasStopped) {\n                      isDone = true;\n                    }\n                    value.__detachAnimation(animation);\n                    isDone = true;\n                    if (!wasStopped) {\n                      wasStopped = false;\n                    }\n                  }),\n                  stopClock(newClock),\n                ]),\n                currentState.position,\n              ])\n            )\n          );\n          value.__attachAnimation(animation);\n          alwaysNode.__addChild(value);\n        }\n      );\n    },\n    __detach: () => {\n      animationCallback && animationCallback({ finished: isDone });\n      animationCallback = null;\n      alwaysNode.__removeChild(value);\n    },\n    stop: () => {\n      if (isDone) {\n        console.warn(\n          'Calling stop has no effect as the animation has already completed'\n        );\n        return;\n      }\n      if (!isStarted) {\n        console.warn(\n          \"Calling stop has no effect as the animation hasn't been started\"\n        );\n        return;\n      }\n      wasStopped = true;\n      evaluateOnce(set(currentState.finished, 1), currentState.finished);\n    },\n    __stopImmediately_testOnly: result => {\n      animation.stop();\n      isDone = result;\n      value.__detachAnimation(animation);\n    },\n  };\n  return animation;\n}\n\n/**\n * Depending on the arguments list we either return animation node or return an\n * animation object that is compatible with the original Animated API\n */\nexport default function backwardsCompatibleAnimWrapper(node, AnimationClass) {\n  return (clock, state, config) => {\n    if (config !== undefined) {\n      return node(clock, state, config);\n    }\n    return createOldAnimationObject(node, AnimationClass, clock, state);\n  };\n}\n"]},"metadata":{},"sourceType":"module"}