{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _inherits from\"@babel/runtime/helpers/inherits\";function _createSuper(Derived){return function(){var Super=_getPrototypeOf(Derived),result;if(_isNativeReflectConstruct()){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}import React from'react';import{createAnimatedAlways}from\"./AnimatedAlways\";import AnimatedNode from\"./AnimatedNode\";var Code=function(_React$Component){_inherits(Code,_React$Component);var _super=_createSuper(Code);function Code(){_classCallCheck(this,Code);return _super.apply(this,arguments);}_createClass(Code,[{key:\"componentDidMount\",value:function componentDidMount(){var _this$props=this.props,children=_this$props.children,exec=_this$props.exec;var nodeChildren=Code.resolveNode(children);var nodeExec=Code.resolveNode(exec);var cantResolveNode=nodeChildren===null&&nodeExec===null;if(cantResolveNode){var error=nodeChildren===null?\"Got \\\"\"+typeof children+\"\\\" type passed to children\":\"Got \\\"\"+typeof exec+\"\\\" type passed to exec\";throw new Error(\"<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. \"+error);}this.always=createAnimatedAlways(nodeExec||nodeChildren);this.always.__attach();}},{key:\"componentWillUnmount\",value:function componentWillUnmount(){this.always.__detach();}},{key:\"render\",value:function render(){return null;}}]);return Code;}(React.Component);Code.resolveNode=function(maybeNode){if(typeof maybeNode==='function'){return Code.resolveNode(maybeNode());}if(maybeNode instanceof AnimatedNode){return maybeNode;}return null;};export default Code;","map":{"version":3,"sources":["/media/blackwolf08/Data/New Projects/Covid-19/COVID19/node_modules/react-native-reanimated/src/core/AnimatedCode.js"],"names":["React","createAnimatedAlways","AnimatedNode","Code","props","children","exec","nodeChildren","resolveNode","nodeExec","cantResolveNode","error","Error","always","__attach","__detach","Component","maybeNode"],"mappings":"m7BAAA,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,OAASC,oBAAT,wBACA,MAAOC,CAAAA,YAAP,sB,GAEMC,CAAAA,I,yPAagB,iBACS,KAAKC,KADd,CACVC,QADU,aACVA,QADU,CACAC,IADA,aACAA,IADA,CAElB,GAAMC,CAAAA,YAAY,CAAGJ,IAAI,CAACK,WAAL,CAAiBH,QAAjB,CAArB,CACA,GAAMI,CAAAA,QAAQ,CAAGN,IAAI,CAACK,WAAL,CAAiBF,IAAjB,CAAjB,CAEA,GAAMI,CAAAA,eAAe,CAAGH,YAAY,GAAK,IAAjB,EAAyBE,QAAQ,GAAK,IAA9D,CAEA,GAAIC,eAAJ,CAAqB,CACnB,GAAMC,CAAAA,KAAK,CACTJ,YAAY,GAAK,IAAjB,UACY,MAAOF,CAAAA,QADnB,uCAEY,MAAOC,CAAAA,IAFnB,yBADF,CAKA,KAAM,IAAIM,CAAAA,KAAJ,2HACsHD,KADtH,CAAN,CAGD,CAED,KAAKE,MAAL,CAAcZ,oBAAoB,CAACQ,QAAQ,EAAIF,YAAb,CAAlC,CACA,KAAKM,MAAL,CAAYC,QAAZ,GACD,C,mEAEsB,CACrB,KAAKD,MAAL,CAAYE,QAAZ,GACD,C,uCAEQ,CACP,MAAO,KAAP,CACD,C,kBAzCgBf,KAAK,CAACgB,S,EAAnBb,I,CACGK,W,CAAc,SAAAS,SAAS,CAAI,CAChC,GAAI,MAAOA,CAAAA,SAAP,GAAqB,UAAzB,CAAqC,CACnC,MAAOd,CAAAA,IAAI,CAACK,WAAL,CAAiBS,SAAS,EAA1B,CAAP,CACD,CAED,GAAIA,SAAS,WAAYf,CAAAA,YAAzB,CAAuC,CACrC,MAAOe,CAAAA,SAAP,CACD,CAED,MAAO,KAAP,CACD,C,CAgCH,cAAed,CAAAA,IAAf","sourcesContent":["import React from 'react';\nimport { createAnimatedAlways } from './AnimatedAlways';\nimport AnimatedNode from './AnimatedNode';\n\nclass Code extends React.Component {\n  static resolveNode = maybeNode => {\n    if (typeof maybeNode === 'function') {\n      return Code.resolveNode(maybeNode());\n    }\n\n    if (maybeNode instanceof AnimatedNode) {\n      return maybeNode;\n    }\n\n    return null;\n  };\n\n  componentDidMount() {\n    const { children, exec } = this.props;\n    const nodeChildren = Code.resolveNode(children);\n    const nodeExec = Code.resolveNode(exec);\n\n    const cantResolveNode = nodeChildren === null && nodeExec === null;\n\n    if (cantResolveNode) {\n      const error =\n        nodeChildren === null\n          ? `Got \"${typeof children}\" type passed to children`\n          : `Got \"${typeof exec}\" type passed to exec`;\n\n      throw new Error(\n        `<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. ${error}`\n      );\n    }\n\n    this.always = createAnimatedAlways(nodeExec || nodeChildren);\n    this.always.__attach();\n  }\n\n  componentWillUnmount() {\n    this.always.__detach();\n  }\n\n  render() {\n    return null;\n  }\n}\nexport default Code;\n"]},"metadata":{},"sourceType":"module"}