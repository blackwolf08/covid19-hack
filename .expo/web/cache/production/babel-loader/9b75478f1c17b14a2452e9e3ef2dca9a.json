{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _inherits from\"@babel/runtime/helpers/inherits\";function _createSuper(Derived){return function(){var Super=_getPrototypeOf(Derived),result;if(_isNativeReflectConstruct()){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}import AnimatedNode from\"./AnimatedNode\";import deepEqual from'fbjs/lib/areEqual';function sanitizeTransform(inputTransform){var outputTransform=[];inputTransform.forEach(function(transform){for(var key in transform){var value=transform[key];if(value instanceof AnimatedNode){outputTransform.push({property:key,nodeID:value.__nodeID});}else{outputTransform.push({property:key,value:value});}}});return outputTransform;}function extractAnimatedParentNodes(transform){var parents=[];transform.forEach(function(transform){for(var key in transform){var value=transform[key];if(value instanceof AnimatedNode){parents.push(value);}}});return parents;}export function createOrReuseTransformNode(transform,oldNode){var config=sanitizeTransform(transform);if(oldNode&&deepEqual(config,oldNode._config)){return oldNode;}return new AnimatedTransform(transform,config);}var AnimatedTransform=function(_AnimatedNode){_inherits(AnimatedTransform,_AnimatedNode);var _super=_createSuper(AnimatedTransform);function AnimatedTransform(transform,config){var _this;_classCallCheck(this,AnimatedTransform);_this=_super.call(this,{type:'transform',transform:config},extractAnimatedParentNodes(transform));_this._config=config;_this._transform=transform;return _this;}_createClass(AnimatedTransform,[{key:\"__onEvaluate\",value:function __onEvaluate(){return this._transform.map(function(transform){var result={};for(var key in transform){var value=transform[key];if(value instanceof AnimatedNode){result[key]=value.__getValue();}}return result;});}}]);return AnimatedTransform;}(AnimatedNode);","map":{"version":3,"sources":["/media/blackwolf08/Data/New Projects/Covid-19/COVID19/node_modules/react-native-reanimated/src/core/AnimatedTransform.js"],"names":["AnimatedNode","deepEqual","sanitizeTransform","inputTransform","outputTransform","forEach","transform","key","value","push","property","nodeID","__nodeID","extractAnimatedParentNodes","parents","createOrReuseTransformNode","oldNode","config","_config","AnimatedTransform","type","_transform","map","result","__getValue"],"mappings":"m7BAAA,MAAOA,CAAAA,YAAP,sBAEA,MAAOC,CAAAA,SAAP,KAAsB,mBAAtB,CAEA,QAASC,CAAAA,iBAAT,CAA2BC,cAA3B,CAA2C,CACzC,GAAMC,CAAAA,eAAe,CAAG,EAAxB,CACAD,cAAc,CAACE,OAAf,CAAuB,SAAAC,SAAS,CAAI,CAClC,IAAK,GAAMC,CAAAA,GAAX,GAAkBD,CAAAA,SAAlB,CAA6B,CAC3B,GAAME,CAAAA,KAAK,CAAGF,SAAS,CAACC,GAAD,CAAvB,CACA,GAAIC,KAAK,WAAYR,CAAAA,YAArB,CAAmC,CACjCI,eAAe,CAACK,IAAhB,CAAqB,CACnBC,QAAQ,CAAEH,GADS,CAEnBI,MAAM,CAAEH,KAAK,CAACI,QAFK,CAArB,EAID,CALD,IAKO,CACLR,eAAe,CAACK,IAAhB,CAAqB,CACnBC,QAAQ,CAAEH,GADS,CAEnBC,KAAK,CAALA,KAFmB,CAArB,EAID,CACF,CACF,CAfD,EAgBA,MAAOJ,CAAAA,eAAP,CACD,CAED,QAASS,CAAAA,0BAAT,CAAoCP,SAApC,CAA+C,CAC7C,GAAMQ,CAAAA,OAAO,CAAG,EAAhB,CACAR,SAAS,CAACD,OAAV,CAAkB,SAAAC,SAAS,CAAI,CAC7B,IAAK,GAAMC,CAAAA,GAAX,GAAkBD,CAAAA,SAAlB,CAA6B,CAC3B,GAAME,CAAAA,KAAK,CAAGF,SAAS,CAACC,GAAD,CAAvB,CACA,GAAIC,KAAK,WAAYR,CAAAA,YAArB,CAAmC,CACjCc,OAAO,CAACL,IAAR,CAAaD,KAAb,EACD,CACF,CACF,CAPD,EAQA,MAAOM,CAAAA,OAAP,CACD,CAED,MAAO,SAASC,CAAAA,0BAAT,CAAoCT,SAApC,CAA+CU,OAA/C,CAAwD,CAC7D,GAAMC,CAAAA,MAAM,CAAGf,iBAAiB,CAACI,SAAD,CAAhC,CACA,GAAIU,OAAO,EAAIf,SAAS,CAACgB,MAAD,CAASD,OAAO,CAACE,OAAjB,CAAxB,CAAmD,CACjD,MAAOF,CAAAA,OAAP,CACD,CACD,MAAO,IAAIG,CAAAA,iBAAJ,CAAsBb,SAAtB,CAAiCW,MAAjC,CAAP,CACD,C,GAEKE,CAAAA,iB,+GACJ,2BAAYb,SAAZ,CAAuBW,MAAvB,CAA+B,mDAC7B,uBACE,CAAEG,IAAI,CAAE,WAAR,CAAqBd,SAAS,CAAEW,MAAhC,CADF,CAEEJ,0BAA0B,CAACP,SAAD,CAF5B,EAIA,MAAKY,OAAL,CAAeD,MAAf,CACA,MAAKI,UAAL,CAAkBf,SAAlB,CAN6B,aAO9B,C,iFAEc,CACb,MAAO,MAAKe,UAAL,CAAgBC,GAAhB,CAAoB,SAAAhB,SAAS,CAAI,CACtC,GAAMiB,CAAAA,MAAM,CAAG,EAAf,CACA,IAAK,GAAMhB,CAAAA,GAAX,GAAkBD,CAAAA,SAAlB,CAA6B,CAC3B,GAAME,CAAAA,KAAK,CAAGF,SAAS,CAACC,GAAD,CAAvB,CACA,GAAIC,KAAK,WAAYR,CAAAA,YAArB,CAAmC,CACjCuB,MAAM,CAAChB,GAAD,CAAN,CAAcC,KAAK,CAACgB,UAAN,EAAd,CACD,CACF,CACD,MAAOD,CAAAA,MAAP,CACD,CATM,CAAP,CAUD,C,+BArB6BvB,Y","sourcesContent":["import AnimatedNode from './AnimatedNode';\n\nimport deepEqual from 'fbjs/lib/areEqual';\n\nfunction sanitizeTransform(inputTransform) {\n  const outputTransform = [];\n  inputTransform.forEach(transform => {\n    for (const key in transform) {\n      const value = transform[key];\n      if (value instanceof AnimatedNode) {\n        outputTransform.push({\n          property: key,\n          nodeID: value.__nodeID,\n        });\n      } else {\n        outputTransform.push({\n          property: key,\n          value,\n        });\n      }\n    }\n  });\n  return outputTransform;\n}\n\nfunction extractAnimatedParentNodes(transform) {\n  const parents = [];\n  transform.forEach(transform => {\n    for (const key in transform) {\n      const value = transform[key];\n      if (value instanceof AnimatedNode) {\n        parents.push(value);\n      }\n    }\n  });\n  return parents;\n}\n\nexport function createOrReuseTransformNode(transform, oldNode) {\n  const config = sanitizeTransform(transform);\n  if (oldNode && deepEqual(config, oldNode._config)) {\n    return oldNode;\n  }\n  return new AnimatedTransform(transform, config);\n}\n\nclass AnimatedTransform extends AnimatedNode {\n  constructor(transform, config) {\n    super(\n      { type: 'transform', transform: config },\n      extractAnimatedParentNodes(transform)\n    );\n    this._config = config;\n    this._transform = transform;\n  }\n\n  __onEvaluate() {\n    return this._transform.map(transform => {\n      const result = {};\n      for (const key in transform) {\n        const value = transform[key];\n        if (value instanceof AnimatedNode) {\n          result[key] = value.__getValue();\n        }\n      }\n      return result;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}